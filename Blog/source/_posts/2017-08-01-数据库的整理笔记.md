---
title: 数据库的整理笔记
date: 2017-08-01 15:50:09
tags: record
categories: 聚沙成塔
---
<!-- TOC -->

## 索引

1. **聚集索引：**索引键值的逻辑顺序与索引所服务的表中相应行的物理顺序**相同**的索引。
2. **非聚集索引：**索引键值的逻辑顺序与索引所服务的表中相应行的物理顺序**不相同**的索引。
<!--more-->
3. **唯一索引：**唯一索引是不允许其中任何两行具有相同索引值的索引。
4. **主键索引：**主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。

&emsp;&emsp;聚集索引的索引值是直接指向数据表对应元组的，而非聚集索引的索引值仍会指向下一个索引数据块，不直接指向元组，因为还有一层索引进行重定向，所以非聚集索引可以拥有不同的键值排序而拥有多个不同的索引。而聚集索引因为与表的元组物理顺序一一对应，所以只有一种排序，即一个数据表只有一个聚集索引。


## 建索引的几大原则
1. 最左端前缀匹配原则：mysql会一直向右匹配直到遇到**范围查询(>、<、between、like)**。
2. “=”和“in”可以乱序，比如a = 1 and b = 2 and c = 3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
3. 尽量选择区分度高的列作为索引，区分度=count(distinct col)/count(*)，表示字段不重复的比例，比例越大，扫描的记录数越少，唯一键的区分度为1。一般需要join的字段的要求是区分度在0.1以上，即平均1条扫描10条记录。
4. 索引列不能参与计算，需要保持列“干净”。例如from_unixtime(create_time) = '2017-08-04'需要改写为create_time = unix_timestamp('2017-08-04')。
5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

## 应该创建索引的列
1. 在经常需要搜索的列上，可以加快搜索的速度；
2. 在经常需要排列的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
3. 在经常使用在WHERE子句的列上面创建索引，加快条件的判断速度；
4. 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
5. 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
6. 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；

## 不应该创建索引的列
第一，对于那些在查询中使用很少或者作为参考的列不应该创建索引。
第二，对于那些只有很少数据值的列不应该增加索引。
第三，对于那些定义为text,image和bit数据类型的列不应该增加索引。因为这些列的数据量要么很大，要么很少。
第四，当修改性能远远大于检索性能时，不应该创建索引。

## 聚集索引

**定义：在聚集索引中，叶节点即数据节点，所有数据航的存储顺序与索引的存储顺序一致。**

当需要在根据此字段查找特定的记录时，数据库系统会根据特定的系统表查找的此索引的根，然后根据指针查找下一个，直到找到。例如我们要查询“Green”，由于它介于[Bennet,Karsen]，据此我们找到了索引页1007，在该页中“Green”介于[Greane, Hunter]间，据此我们找到叶结点1133（也即数据结点），并最终在此页中找以了目标数据行。

{% asset_img 聚集索引.JPG 聚集索引 %}

## 非聚集索引

聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。
而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。

{% asset_img 非聚集索引.JPG 非聚集索引 %}

## 非聚集索引与聚集索引对比
A）叶子结点并非数据结点
B）叶子结点为每一真正的数据行存储一个“键-指针”对
C）叶子结点中还存储了一个指针偏移量，根据页指针及指针偏移量可以定位到具体的数据行。
D）类似的，在除叶结点外的其它索引结点，存储的也是类似的内容，只不过它是指向下一级的索引页的。

## 索引的实现原理

&emsp;&emsp;索引一般采用B树/B+树来实现，当然也有例外，Memory引擎显示支持哈希索引，我们接下来分别进行讨论。

### B-Tree索引 
&emsp;&emsp;B-Tree是MyISAM和InnoDB引擎默认索引类型,也可以在创建索引时通过USING BTREE来显示指定。B-Tree是一种多叉平衡树,B-Tree 结构可以显著减少定位记录时所经历的中间过程,从而加快存取速度。一般用于数据库的索引,综合效率较高。

### B-Tree索引的应用场景
	
	- 等值匹配 
	可用于= != <> IN NOT IN <=>查询语句的优化
	- 范围匹配 
	可用于 > >= < <= BTEWEEN AND等范围查询语句的优化
	- 匹配最左前缀 
	对于 name like bai% 这种后模糊匹配的查询,是可以利用name字段上建立的索引来优化查询的,但是对于name like %bai这种前模糊匹配的查询则没有办法使用索引了
	- 覆盖索引 
	B-Tree索引的key存放的是字段的值,如果key中包含所有需要查询字段的值,我们就称之为覆盖索引,覆盖索引能够极大的提高性能。
	- 排序 
	B-Tree索引是排好序的,所以MySQL可以用来优化ORDER BY 和 GROUP BY等操作。

### 哈希索引(HASH) 
&emsp;&emsp;哈希索引基于哈希表实现,只有Memory引擎显示支持哈希索引,使用哈希索引可以一次定位,所以 Hash 索引的查询效率要远高于 B-Tree 索引。但是哈希索引是有很多限制的:
	- 只有精确匹配索引所有列的查询才有效,因为哈希索引是利用索引的所有列的字段值来计算哈希值的。
	- 只支持等值比较查询,不能用于范围查询。
	- 哈希索引的只包含索引字段的哈希值和指向数据的指针,所以不能使用索引中的值来避免读取行。
	- 哈希索引的数据并不是顺序存储的,无法用于排序。
	
### 全文索引(FULLTEXT) 
全文索引,是一种通过建立倒排索引,快速匹配文档的方式。

### 空间索引(SPATIAL) 
MyISAM支持空间索引,可以用作地理数据的存储。

## InnoDB与MyISAM的区别
  1. InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。
  2. MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用
  3. InnoDB支持外键，MyISAM不支持
  4. MyISAM是默认引擎，InnoDB需要指定
  5. InnoDB不支持FULLTEXT类型的索引
  6. InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表
  7. 对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引
  8. 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表
  9. InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'）


## 参考文献

1. [维基百科：索引](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95)
2. [MySQL索引原理及慢查询优化](https://tech.meituan.com/mysql-index.html)
3. [数据库进阶系列之一：漫谈数据库索引](http://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html)
4. [MySQL索引详解](http://shanks.leanote.com/post/Mysql%E7%B4%A2%E5%BC%95)