---
title: 聊聊操作系统
date: 2017-08-20 23:22:45
tags: Operating System
categories: 聚沙成塔
---

<!--TOC-->

## Linux

### SWAP的概述

SWAP就是LINUX下的虚拟内存分区，它的作用是在物理内存使用完之后,将磁盘空间(也就是SWAP分区)虚拟成内存来使用。

SWAP的作用可简单描述为：当内存不够用时，将存储器中的数据块从DRAM移到SWAP的磁盘空间中，以释放更多的空间给当前进程使用。当再次需要那些数据时，就可以将swap磁盘中的数据重新移到内存，而将那些不用的数据块从内存移到SWAP中。

<!--more-->

数据从内存移动交换区的行为被称为页面调用，发生在后台的页面调用没有来自应用程序的干涉。

SWAP空间是分页的，每一页的大小和内存也大小是一样的。

并不是一定要给每个系统划分SWAP，比如大多数的嵌入式就没有SWAP分区。

值得注意的是：并不是所有从物理内存中交换出来的数据都会被放到Swap中（如果这样的话，Swap就会不堪重负），有相当一部分数据被直接交换到文件系统。例如，有的程序会打开一些文件，对文件进行读写（其实每个程序都至少要打开一个文件，那就是运行程序本身），当需要将这些程序的内存空间交换出去时，就没有必要将文件部分的数据放到Swap空间中了，而可以直接将其放到文件里去。如果是读文件操作，那么内存数据被直接释放，不需要交换出来，因为下次需要时，可直接从文件系统恢复；如果是写文件，只需要将变化的数据保存到文件中，以便恢复。但是那些用malloc和new函数生成的对象的数据则不同，它们需要Swap空间，因为它们在文件系统中没有相应的“储备”文件，因此被称作“匿名”(Anonymous)内存数据。这类数据还包括堆栈中的一些状态和变量数据等。所以说，Swap空间是“匿名”数据的交换空间。

### fork函数

fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。

一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。

当执行fork()函数后，会生成一个子进程，子进程的执行从fork()的返回值开始且代码继续往下执行。

fork()执行一次后会有两次返回值：第一次为原来的进程，即父进程会有一次返回值，表示新生成的子进程的进程ID；第二次为子进程的起始执行，返回值为0。

#### fork函数的返回值
**fpid=fork()值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0。**

fork()可能有三种不同的返回值：
1）在父进程中，fork返回新创建子进程的进程ID；
2）在子进程中，fork返回0；
3）如果出现错误，fork返回一个负值；
	
#### fork出错的原因 
1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
2）系统内存不足，这时errno的值被设置为ENOMEM。

#### fork使用场景
- 守护进程
&emsp;&emsp;有时为了保护主进程不被杀，或者主进程异外退出后仍可再次启动(或后台运行)，就执行fork()让子进程监控主进程的运行状态，根据监听保护主进程的运行。

- 框架扩展
&emsp;&emsp;主进程只负责生成子进程，派出子进程去执行应用框架下的子任务，这些任务可能多变、可能更新频繁，但配合fork()及exec()函数，一切都是so easy..还保证了主进程的稳定，避免频繁更新程序。

## 管程

### 定义

管程的定义：由表示共享资源的抽象数据结构和对该共享数据结构的一组操作所组成的资源管理程序叫管程 。管程封装了共享资源及对于共享资源的操作，别的进程不能直接访问这些资源，因此管程也可以成为资源管理类。

1. 一个管程定义了一个数据结构和对该数据结构上的一组操作，这组操作能同步进程并改变管程中的数据。
2. 局部于管程的数据结构，只能被局部于管程的操作所访问，任何管程之外的操作都不能访问它；反之，局部于管程的操作也只能访问管程内的数据结构。由此可见，管程相当于围墙，它把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程，从而实现了进程的互斥。

### 管程的组成
1. 一个互斥锁：进入管程时加锁，离开管程时解锁 —— 用于确保了在一个时间点，最多只有一个线程占用该管程。
2. 共享资源的数据结构：用于表示管程内部的共享资源
3. 对共享资源（数据结构）的一组操作：用于同步进程并改变管程中的数据
4. 一个用来避免竞态条件的不变量：用于判断管程内部的共享资源是否能被使用（在进入管程后，离开管程前判断）
5. 紧急等待队列：用于存放等待管程或共享资源的使用权的进程

### 管程的优势

1. 集中化管理资源：管程实现了同一时刻最多只有一个线程执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计 —— 类似于将原来的分布式资源管理变成集中式资源管理。
2. 互斥地使用管程：管程把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程，从而实现了进程的互斥。
3. 管程内部信息隐藏：管程外的进程或其他软件模块只能通过管程对外的接口来访问管程提供的操作，管程内部的实现细节对外界是透明的。
4. 使系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表示该资源，从而忽略它们的内部结构和实现细节。

## 死锁

### 四个必要条件

〈1〉互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。

〈2〉不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。

〈3〉占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。

〈4〉循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。

## mmap